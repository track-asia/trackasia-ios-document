import SwiftUI
import TrackAsia
import CoreLocation
import MapboxDirections
import MapboxCoreNavigation

class MapViewModel: ObservableObject {
    // MARK: - Properties
    @Published var mode: MapMode = .singlePoint
    @Published var isStyleLoaded: Bool = false
    @Published var currentCountry: String = "vn"
    @Published var isAnimating: Bool = false
    @Published var currentRoute: Route?
    @Published var waypoints: [CLLocationCoordinate2D] = []
    @Published var currentTabIndex: Int?
    @Published var showCompareView: Bool = false
    @Published var searchText: String = ""
    @Published var isMapReady: Bool = false
    @Published var featureOptions: [String: Bool] = [
        "showMarkers": false,
        "showPolyline": false,
        "showPolygon": false,
        "showHeatmap": false,
        "showBuildings3D": false
    ]
    
    // Navigation-specific properties
    @Published var navigationMode: NavigationMode = .planning
    @Published var startPoint: CLLocationCoordinate2D?
    @Published var endPoint: CLLocationCoordinate2D?
    
    // Callback for map taps
    var onMapTapped: ((CLLocationCoordinate2D) -> Void)?
    
    var mapViewManager = MapViewManager()
    
    // MARK: - Initialization
    init() {
        setupMapView()
        configureURLSessionTimeouts()
    }
    
    // MARK: - Setup Methods
    private func setupMapView() {
        mapViewManager.setupMapView()
    }
    
    // C·∫•u h√¨nh timeout cho c√°c y√™u c·∫ßu m·∫°ng
    private func configureURLSessionTimeouts() {
        // TƒÉng th·ªùi gian timeout cho c√°c y√™u c·∫ßu t√†i nguy√™n
        URLSessionConfiguration.default.timeoutIntervalForResource = 60.0 // 60 gi√¢y
        URLSessionConfiguration.default.timeoutIntervalForRequest = 60.0 // 60 gi√¢y
        
        // ƒê·∫£m b·∫£o URL Session s·ª≠ d·ª•ng c·∫•u h√¨nh m·ªõi
        URLSession.shared.reset {
            print("üîÑ URLSession ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh l·∫°i v·ªõi timeout d√†i h∆°n")
        }
    }
    
    // MARK: - Map State Management
    func updateMap(selectedCountry: String) {
        // C·∫≠p nh·∫≠t qu·ªëc gia
        currentCountry = selectedCountry
        
        // C·∫≠p nh·∫≠t style v√† camera
        let latLng = MapUtils.getLatlng(idCountry: selectedCountry)
        // Chuy·ªÉn ƒë·ªïi t·ª´ LatLng sang CLLocationCoordinate2D
        let coordinate = latLng.toCLLocationCoordinate2D()
        mapViewManager.moveCamera(to: coordinate, zoom: 12)
    }
    
    func restoreMapState() {
        // Kh√¥i ph·ª•c tr·∫°ng th√°i b·∫£n ƒë·ªì sau khi style ƒë√£ t·∫£i
        updateMap(selectedCountry: currentCountry)
    }
    
    // MARK: - Mode Management
    func updateMode(_ selectedMode: MapMode) {
        if mode != selectedMode {
            print("üîÑ ƒêang thay ƒë·ªïi ch·∫ø ƒë·ªô t·ª´ \(mode) sang \(selectedMode)")
            
            // X·ª≠ l√Ω khi tho√°t kh·ªèi ch·∫ø ƒë·ªô hi·ªán t·∫°i
            switch mode {
            case .navigation:
                waypoints.removeAll()
                mapViewManager.removeAllPolylines()
                clearAllAnnotations()
            case .feature:
                prepareFeatureMode()
            case .compare:
                hideCompareView()
            case .animation:
                stopAnimating()
            default:
                break
            }
            
            // Reset onMapTapped callback khi chuy·ªÉn mode
            print("üîÑ Resetting onMapTapped callback in MapViewModel")
            onMapTapped = nil
            
            // C·∫≠p nh·∫≠t ch·∫ø ƒë·ªô m·ªõi
            mode = selectedMode
            
            // X·ª≠ l√Ω khi v√†o ch·∫ø ƒë·ªô m·ªõi
            switch selectedMode {
            case .navigation:
                mapViewManager.addMapLongPressGesture()
            case .animation:
                createSampleRoute()
            case .heatmap:
                setupHeatmap()
            case .cluster:
                setupClusterPoints()
            case .compare:
                setupCompareView()
            default:
                break
            }
            
            print("‚úÖ ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô: \(selectedMode)")
        }
    }
    
    func prepareForModeChange() {
        // Clean up resources from previous mode
        clearAllAnnotations()
        stopAnimating()
        
        // X√≥a c√°c d·ªØ li·ªáu ƒë·∫∑c bi·ªát
        if mode == .wayPoint {
            waypoints.removeAll()
        }
        
        // Reset compare view status if leaving compare mode
        if mode == .compare {
            showCompareView = false
        }
    }
    
    func setupForCurrentMode() {
        // Thi·∫øt l·∫≠p d·ª±a v√†o ch·∫ø ƒë·ªô m·ªõi
        switch mode {
        case .singlePoint:
            // Kh√¥ng c·∫ßn thi·∫øt l·∫≠p b·ªï sung
            break
        case .wayPoint:
            // X√≥a waypoints
            waypoints.removeAll()
        case .cluster:
            setupClusterPoints()
        case .animation:
            setupAnimationRoute()
        case .feature:
            prepareFeatureMode()
        case .compare:
            // Setup compare mode
            break
        }
    }
    
    // MARK: - Feature-specific Methods
    
    // SinglePoint Mode
    func addMarker(at coordinate: CLLocationCoordinate2D, title: String) {
        // X√≥a marker c≈© (n·∫øu ·ªü ch·∫ø ƒë·ªô single point)
        if mode == .singlePoint {
            clearAllAnnotations()
        }
        
        // Th√™m marker m·ªõi
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = title
        mapViewManager.mapView.addAnnotation(annotation)
        
        // Di chuy·ªÉn camera ƒë·∫øn v·ªã tr√≠ marker
        mapViewManager.moveCamera(to: coordinate, zoom: 14)
    }
    
    // WayPoint Mode
    func addWaypoint(at coordinate: CLLocationCoordinate2D) {
        // Th√™m waypoint v√†o danh s√°ch
        waypoints.append(coordinate)
        
        // Th√™m annotation
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = "Waypoint \(waypoints.count)"
        mapViewManager.mapView.addAnnotation(annotation)
        
        // N·∫øu c√≥ t·ª´ 2 ƒëi·ªÉm tr·ªü l√™n, v·∫Ω ƒë∆∞·ªùng n·ªëi
        if waypoints.count >= 2 {
            drawPolylineBetweenWaypoints()
        }
    }
    
    func drawPolylineBetweenWaypoints() {
        // X√≥a polyline c≈©
        mapViewManager.removeAllPolylines()
        
        // V·∫Ω polyline m·ªõi
        mapViewManager.addPolyline(coordinates: waypoints)
    }
    
    func clearWaypoints() {
        // Remove waypoint annotations
        if let annotations = mapViewManager.mapView.annotations?.filter({ annotation in
            if let title = annotation.title {
                return ((title?.contains("Waypoint")) != nil) || ((title?.contains("ƒêi·ªÉm")) != nil)
            }
            return false
        }) {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
        
        // Clear route overlays
        mapViewManager.removeAllPolylines()
        
        // Clear data
        waypoints.removeAll()
        currentRoute = nil
        startPoint = nil
        endPoint = nil
        
        print("Waypoints and route cleared")
    }
    
    // Cluster Mode
    func setupClusterPoints() {
        print("üîÑ Setting up cluster points in MapViewModel")
        
        // Avoid adding random points if we're using ClusterView
        // Instead, let ClusterView handle the data from GeoJSON
        
        // Center the map on the selected country
        let latLng = MapUtils.getLatlng(idCountry: currentCountry)
        let centerCoordinate = latLng.toCLLocationCoordinate2D()
        
        // Set an appropriate zoom level for viewing clusters
        mapViewManager.moveCamera(to: centerCoordinate, zoom: 8)
        print("üìç Centered map for cluster view at \(centerCoordinate.latitude), \(centerCoordinate.longitude), zoom: 8")
    }
    
    // Animation Mode
    func setupAnimationRoute() {
        // T·∫°o tuy·∫øn ƒë∆∞·ªùng m·∫´u n·∫øu ch∆∞a c√≥
        if currentRoute == nil {
            createSampleRoute()
        }
        
        // Hi·ªÉn th·ªã tuy·∫øn ƒë∆∞·ªùng n·∫øu c√≥
        if let route = currentRoute, let coordinates = route.coordinates {
            mapViewManager.addAnimationPolyline(coordinates: coordinates)
        }
    }
    
    func createSampleRoute() {
        let latLng = MapUtils.getLatlng(idCountry: currentCountry)
        let originCoordinate = latLng.toCLLocationCoordinate2D()
        let destinationCoordinate = CLLocationCoordinate2D(
            latitude: originCoordinate.latitude + 0.05,
            longitude: originCoordinate.longitude + 0.05
        )
        
        let origin = Waypoint(coordinate: originCoordinate)
        let destination = Waypoint(coordinate: destinationCoordinate)
        
        // Th√™m explicit type annotation ƒë·ªÉ tr√°nh l·ªói heterogeneous collection
        let coordinatesArray: [[Double]] = [
            [originCoordinate.longitude, originCoordinate.latitude], 
            [destinationCoordinate.longitude, destinationCoordinate.latitude]
        ]
        
        // T·∫°o tuy·∫øn ƒë∆∞·ªùng m·∫´u
        currentRoute = Route(
            json: ["coordinates": coordinatesArray],
            waypoints: [origin, destination],
            options: NavigationRouteOptions(waypoints: [origin, destination])
        )
    }
    
    func startAnimating() {
        self.isAnimating = true
        mapViewManager.startAnimatingPolyline()
    }
    
    func stopAnimating() {
        self.isAnimating = false
        mapViewManager.stopAnimatingPolyline()
    }
    
    // Feature Mode
    func prepareFeatureMode() {
        // X√≥a t·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng hi·ªán t·∫°i
        clearAllAnnotations()
        mapViewManager.removeAllPolylines()
    }
    
    func addFeatureMarkers() {
        // Th√™m markers m·∫´u
        let locations = [
            CLLocationCoordinate2D(latitude: 21.028511, longitude: 105.854444), // Hanoi
            CLLocationCoordinate2D(latitude: 10.823099, longitude: 106.629662), // Ho Chi Minh City
            CLLocationCoordinate2D(latitude: 16.463714, longitude: 107.590866)  // Hue
        ]
        
        for (index, location) in locations.enumerated() {
            let annotation = MLNPointAnnotation()
            annotation.coordinate = location
            annotation.title = "Feature Location \(index + 1)"
            mapViewManager.mapView.addAnnotation(annotation)
        }
    }
    
    func addFeaturePolyline() {
        // Th√™m polyline m·∫´u
        let locations = [
            CLLocationCoordinate2D(latitude: 21.028511, longitude: 105.854444), // Hanoi
            CLLocationCoordinate2D(latitude: 16.463714, longitude: 107.590866), // Hue
            CLLocationCoordinate2D(latitude: 10.823099, longitude: 106.629662)  // Ho Chi Minh City
        ]
        
        mapViewManager.addPolyline(coordinates: locations)
    }
    
    func addFeaturePolygon() {
        // Th√™m polygon m·∫´u
        let locations = [
            CLLocationCoordinate2D(latitude: 21.028511, longitude: 105.854444), // Hanoi
            CLLocationCoordinate2D(latitude: 16.463714, longitude: 107.590866), // Hue
            CLLocationCoordinate2D(latitude: 10.823099, longitude: 106.629662), // Ho Chi Minh City
            CLLocationCoordinate2D(latitude: 21.028511, longitude: 105.854444)  // ƒê√≥ng polygon b·∫±ng c√°ch l·∫∑p l·∫°i ƒëi·ªÉm ƒë·∫ßu ti√™n
        ]
        
        mapViewManager.addPolygon(coordinates: locations)
    }
    
    // MARK: - Compare Mode
    
    func setupCompareView() {
        // Hi·ªÉn th·ªã ch·∫ø ƒë·ªô so s√°nh
        showCompareView = true
        
        // N·∫øu c·∫ßn th√™m c·∫•u h√¨nh ƒë·∫∑c bi·ªát cho ch·∫ø ƒë·ªô so s√°nh
        if let currentCoord = mapViewManager.mapView.userLocation?.coordinate, 
           CLLocationCoordinate2DIsValid(currentCoord) {
            // S·ª≠ d·ª•ng v·ªã tr√≠ ng∆∞·ªùi d√πng n·∫øu c√≥
            mapViewManager.moveCamera(to: currentCoord, zoom: 14)
        } else {
            // N·∫øu kh√¥ng c√≥ v·ªã tr√≠ ng∆∞·ªùi d√πng, s·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh
            let latLng = MapUtils.getLatlng(idCountry: currentCountry)
            mapViewManager.moveCamera(to: latLng.toCLLocationCoordinate2D(), zoom: 14)
        }
    }
    
    func hideCompareView() {
        // Implementation for hiding the compare view
        showCompareView = false
    }
    
    // MARK: - Location Services
    func centerOnUserLocation() {
        print("üìç Attempting to center on user location")
        
        if let userLocation = self.mapViewManager.getUserLocation() {
            print("‚úÖ Found user location at: \(userLocation.coordinate.latitude), \(userLocation.coordinate.longitude)")
            self.mapViewManager.moveCamera(to: userLocation.coordinate, zoom: 14)
        } else {
            // Default to a location in Hanoi if user location isn't available
            print("‚ö†Ô∏è No user location available, defaulting to Hanoi")
            let hanoi = CLLocationCoordinate2D(latitude: 21.028511, longitude: 105.854444)
            self.mapViewManager.moveCamera(to: hanoi, zoom: 12)
        }
    }
    
    // MARK: - Map Tap Handlers
    func handleSinglePointTap(at coordinate: CLLocationCoordinate2D) {
        // X·ª≠ l√Ω tap trong ch·∫ø ƒë·ªô single point
        if mode == .singlePoint {
            addMarker(at: coordinate, title: "V·ªã tr√≠ ƒë√£ ch·ªçn")
        }
    }
    
    func handleWaypointTap(at coordinate: CLLocationCoordinate2D) {
        print("üìç Adding waypoint at: \(coordinate.latitude), \(coordinate.longitude)")
        
        // Add the coordinate to the waypoints array
        waypoints.append(coordinate)
        
        // Add a marker on the map for this waypoint
        addMarker(at: coordinate, title: "Waypoint \(waypoints.count)")
        
        // If we have 2+ waypoints, we can potentially draw a route
        if waypoints.count >= 2 {
            print("‚úÖ Now have \(waypoints.count) waypoints, can calculate route")
        }
    }
    
    func handleClusterTap(at coordinate: CLLocationCoordinate2D) {
        // X·ª≠ l√Ω tap trong ch·∫ø ƒë·ªô cluster
        print("Tap in cluster mode at: \(coordinate.latitude), \(coordinate.longitude)")
    }
    
    func handleAnimationTap(at coordinate: CLLocationCoordinate2D) {
        // X·ª≠ l√Ω tap trong ch·∫ø ƒë·ªô animation
        print("Tap in animation mode at: \(coordinate.latitude), \(coordinate.longitude)")
    }
    
    func handleFeatureTap(at coordinate: CLLocationCoordinate2D) {
        // X·ª≠ l√Ω tap trong ch·∫ø ƒë·ªô feature
        addMarker(at: coordinate, title: "Feature Location")
    }
    
    func reverseGeocode(coordinate: CLLocationCoordinate2D) {
        // Th·ª±c hi·ªán geocoding ng∆∞·ª£c ƒë·ªÉ l·∫•y ƒë·ªãa ch·ªâ
        print("Reverse geocoding at: \(coordinate.latitude), \(coordinate.longitude)")
        // Th√™m code geocoding th·ª±c t·∫ø ·ªü ƒë√¢y n·∫øu c·∫ßn
    }
    
    func requestUserLocation() {
        // Y√™u c·∫ßu v·ªã tr√≠ ng∆∞·ªùi d√πng
        centerOnUserLocation()
    }
    
    func searchLocation(query: String) {
        // T√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm
        print("Searching for location: \(query)")
        // Th√™m code t√¨m ki·∫øm th·ª±c t·∫ø ·ªü ƒë√¢y n·∫øu c·∫ßn
    }
    
    // MARK: - Helper Methods
    private func clearAllAnnotations() {
        if let annotations = mapViewManager.mapView.annotations {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
    }
    
    private func generateRandomPoints(around center: CLLocationCoordinate2D, count: Int, radiusInKm: Double) -> [CLLocationCoordinate2D] {
        var points: [CLLocationCoordinate2D] = []
        
        for _ in 0..<count {
            // T·∫°o ƒëi·ªÉm ng·∫´u nhi√™n trong b√°n k√≠nh
            let radiusInDegrees = radiusInKm / 111.32 // 1 ƒë·ªô ~ 111.32km
            
            let u = Double.random(in: 0...1)
            let v = Double.random(in: 0...1)
            let w = radiusInDegrees * sqrt(u)
            let t = 2 * .pi * v
            let x = w * cos(t)
            let y = w * sin(t)
            
            let newLat = center.latitude + y
            let newLng = center.longitude + x / cos(center.latitude * .pi / 180)
            
            points.append(CLLocationCoordinate2D(latitude: newLat, longitude: newLng))
        }
        
        return points
    }
    
    // Helper method to clear the map (annotations, polylines, etc.)
    func clearMap() {
        clearAllAnnotations()
        mapViewManager.removeAllPolylines()
    }
    
    // MARK: - Feature Management
    func toggleFeatureOption(_ option: String) {
        featureOptions[option] = !(featureOptions[option] ?? false)
        
        // Th·ª±c hi·ªán c√°c h√†nh ƒë·ªông c·ª• th·ªÉ d·ª±a tr√™n t√πy ch·ªçn
        switch option {
        case "showMarkers":
            if featureOptions[option] == true {
                addFeatureMarkers()
            } else {
                clearAllAnnotations()
            }
        case "showPolyline":
            if featureOptions[option] == true {
                addFeaturePolyline()
            } else {
                mapViewManager.removeAllPolylines()
            }
        case "showPolygon":
            if featureOptions[option] == true {
                addFeaturePolygon()
            } else {
                // X√≥a polygon n·∫øu c·∫ßn
            }
        case "showHeatmap":
            if featureOptions[option] == true {
                // Th√™m m√£ hi·ªÉn th·ªã heatmap
            } else {
                // ·∫®n heatmap
            }
        case "showBuildings3D":
            if featureOptions[option] == true {
                // Hi·ªÉn th·ªã t√≤a nh√† 3D
            } else {
                // ·∫®n t√≤a nh√† 3D
            }
        case "showCompare":
            // ƒê∆∞·ª£c x·ª≠ l√Ω ri√™ng trong MapFeatureView
            break
        default:
            break
        }
    }
    
    // MARK: - Waypoint Management Methods

    // Ph∆∞∆°ng th·ª©c m·ªõi v·ªõi t√™n ho√†n to√†n kh√°c ƒë·ªÉ tr√°nh xung ƒë·ªôt
    public func markStartLocation(at coordinate: CLLocationCoordinate2D, withTitle title: String) {
        print("ƒêang ƒë√°nh d·∫•u ƒëi·ªÉm ƒëi t·∫°i: \(coordinate.latitude), \(coordinate.longitude)")
        // Remove existing start point if any
        if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒëi" }) {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
        
        // Set the new start point
        self.startPoint = coordinate
        
        // Add an annotation for the start point
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = title
        mapViewManager.mapView.addAnnotation(annotation)
        
        // Move camera to this point
        mapViewManager.moveCamera(to: coordinate, zoom: 14)
    }
    
    public func markEndLocation(at coordinate: CLLocationCoordinate2D, withTitle title: String) {
        print("ƒêang ƒë√°nh d·∫•u ƒëi·ªÉm ƒë·∫øn t·∫°i: \(coordinate.latitude), \(coordinate.longitude)")
        // Remove existing end point if any
        if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒë·∫øn" }) {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
        
        // Set the new end point
        self.endPoint = coordinate
        
        // Add an annotation for the end point
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = title
        mapViewManager.mapView.addAnnotation(annotation)
        
        // If we have both start and end, make sure to show both
        if startPoint != nil && endPoint != nil {
            // Could add logic to fit both points in view
        }
    }
    
    // MARK: - Navigation Methods
    
    public func addStartMarker(coordinate: CLLocationCoordinate2D, title: String) {
        // Remove existing start point if any
        if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒëi" }) {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
        
        // Set the new start point
        self.startPoint = coordinate
        
        // Add an annotation for the start point
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = title
        mapViewManager.mapView.addAnnotation(annotation)
        
        // Move camera to this point
        mapViewManager.moveCamera(to: coordinate, zoom: 14)
    }
    
    public func addEndMarker(coordinate: CLLocationCoordinate2D, title: String) {
        // Remove existing end point if any
        if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒë·∫øn" }) {
            mapViewManager.mapView.removeAnnotations(annotations)
        }
        
        // Set the new end point
        self.endPoint = coordinate
        
        // Add an annotation for the end point
        let annotation = MLNPointAnnotation()
        annotation.coordinate = coordinate
        annotation.title = title
        mapViewManager.mapView.addAnnotation(annotation)
        
        // If we have both start and end, make sure to show both
        if startPoint != nil && endPoint != nil {
            // Could add logic to fit both points in view
        }
    }
    
    public func setStartPoint(coordinate: CLLocationCoordinate2D, title: String) {
        // Chuy·ªÉn h∆∞·ªõng sang ph∆∞∆°ng th·ª©c m·ªõi ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi @Published
        addStartMarker(coordinate: coordinate, title: title)
    }
    
    public func setEndPoint(coordinate: CLLocationCoordinate2D, title: String) {
        // Chuy·ªÉn h∆∞·ªõng sang ph∆∞∆°ng th·ª©c m·ªõi ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi @Published
        addEndMarker(coordinate: coordinate, title: title)
    }
    
    public func updateWaypoint(coordinate: CLLocationCoordinate2D, title: String, isStartPoint: Bool) {
        if isStartPoint {
            // Remove existing start point if any
            if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒëi" }) {
                mapViewManager.mapView.removeAnnotations(annotations)
            }
            
            // Set the new start point
            self.startPoint = coordinate
            
            // Add an annotation for the start point
            let annotation = MLNPointAnnotation()
            annotation.coordinate = coordinate
            annotation.title = title
            mapViewManager.mapView.addAnnotation(annotation)
            
            // Move camera to this point
            mapViewManager.moveCamera(to: coordinate, zoom: 14)
        } else {
            // Remove existing end point if any
            if let annotations = mapViewManager.mapView.annotations?.filter({ $0.title == "ƒêi·ªÉm ƒë·∫øn" }) {
                mapViewManager.mapView.removeAnnotations(annotations)
            }
            
            // Set the new end point
            self.endPoint = coordinate
            
            // Add an annotation for the end point
            let annotation = MLNPointAnnotation()
            annotation.coordinate = coordinate
            annotation.title = title
            mapViewManager.mapView.addAnnotation(annotation)
            
            // If we have both start and end, make sure to show both
            if startPoint != nil && endPoint != nil {
                // Could add logic to fit both points in view
            }
        }
    }
    
    func calculateRoute(from start: CLLocationCoordinate2D, to end: CLLocationCoordinate2D, completion: @escaping (Bool, String?) -> Void) {
        // Clear any existing route
        mapViewManager.removeAllPolylines()
        
        // Create waypoints for the start and end points
        let origin = Waypoint(coordinate: start)
        let destination = Waypoint(coordinate: end)
        
        // Set up the route options
        let routeOptions = NavigationRouteOptions(waypoints: [origin, destination])
        
        // For this demo, we'll just create a simple straight line route
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            guard let self = self else { return }
            
            // Create a simple route with just the start and end points
            let coordinatesArray: [[Double]] = [
                [start.longitude, start.latitude], 
                [end.longitude, end.latitude]
            ]
            
            // Create a sample route
            self.currentRoute = Route(
                json: ["coordinates": coordinatesArray],
                waypoints: [origin, destination],
                options: routeOptions
            )
            
            // Draw the route on the map
            self.mapViewManager.addPolyline(coordinates: [start, end])
            
            // Update navigation mode
            self.navigationMode = .route
            
            // Call the completion handler
            completion(true, "Route calculated successfully")
        }
        
        // In a real app, you would actually call the MapBox Directions API here
        // Directions.shared.calculate(routeOptions) { (waypoints, routes, error) in ... }
    }
    
    func reverseGeocode(coordinate: CLLocationCoordinate2D) async -> CLPlacemark? {
        let geocoder = CLGeocoder()
        let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
        
        do {
            let placemarks = try await geocoder.reverseGeocodeLocation(location)
            return placemarks.first
        } catch {
            print("Reverse geocoding error: \(error.localizedDescription)")
            return nil
        }
    }
}

// MARK: - Enums
public enum MapMode {
    case singlePoint
    case wayPoint
    case cluster
    case animation
    case heatmap
    case compare
    case feature
    case navigation
}

public enum NavigationMode {
    case planning
    case active
    case complete
}

// MARK: - CLPlacemark Extension
extension CLPlacemark {
    func getFormattedAddress() -> String {
        var addressString = ""
        
        if let name = self.name {
            addressString += name
        }
        
        if let thoroughfare = self.thoroughfare {
            if !addressString.isEmpty {
                addressString += ", "
            }
            addressString += thoroughfare
        }
        
        if let subThoroughfare = self.subThoroughfare {
            if !addressString.isEmpty && !addressString.contains(subThoroughfare) {
                addressString += " " + subThoroughfare
            }
        }
        
        if let subLocality = self.subLocality {
            if !addressString.isEmpty {
                addressString += ", "
            }
            addressString += subLocality
        }
        
        if let locality = self.locality {
            if !addressString.isEmpty {
                addressString += ", "
            }
            addressString += locality
        }
        
        if let administrativeArea = self.administrativeArea {
            if !addressString.isEmpty {
                addressString += ", "
            }
            addressString += administrativeArea
        }
        
        if let postalCode = self.postalCode {
            if !addressString.isEmpty {
                addressString += " "
            }
            addressString += postalCode
        }
        
        if let country = self.country {
            if !addressString.isEmpty {
                addressString += ", "
            }
            addressString += country
        }
        
        return addressString
    }
} 